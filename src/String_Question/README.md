* 字符串类型
    * [005--替换空格](Solution005.java)
    * [019--正则表达式匹配](Solution019.java)
    * [020--表示数值的字符串](Solution020.java)
    * [038--字符串的排列](Solution038.java)
    * [058(1)--翻转单词顺序](Solution058_1.java)
    * [058(2)--左旋转字符串](Solution058_2.java)
    * [067--字符串转换成整数](Solution067.java)

   



解题思路
------
### [005--替换空格](Solution005.java)
&nbsp;&nbsp;此题输入一个带空格的字符串，并将空格替换为“%20”。<br>
&nbsp;&nbsp;解题思路先进行一次遍历统计空格数，在设置替换空格后的新字符串长度为旧字符串长度+空格数x2，因为要替换的东西比空格长2。再设置两个指针，一个指向旧字符串的旧长度末尾，一个指向新字符串的新长度末尾，同时向前移动，遇到空格替换。<br>

### [019--正则表达式匹配](Solution019.java)
&nbsp;&nbsp;请实现一个函数用来匹配包含‘.’和‘\*’的正则表达式。<br>
&nbsp;&nbsp;解题思路是每次从字符串中拿出一个字符和模式的字符去匹配。如果现在模式中的是'.'则可以匹配字符串中任意字符，若'.'后面是'\*',则继续匹配任意字符；若模式中的字符不是'.'，但字符串现在的字符和模式中字符一样，则它们相互匹配，继续匹配后面的字符；若后面的字符既不是'.\*'，又不是相同的字符，则不匹配返回false；当模式中字符为'\*'时，一种选择是在模式上向后移动两个字符，相当于'\*'和前面的字符被忽略了，因为'\*'可以匹配0个字符；若模式与字符串中第一个字符匹配了，则字符串向后移动一个字符，模式可以有两种选择：一是在模式上向后移动两个字符、二是保持模式不变。<br>

### [020--表示数值的字符串](Solution020.java)
&nbsp;&nbsp;请设计一个函数用来判断字符串是否表示数值(包括整数，小数，指数)。<br>
&nbsp;&nbsp;数值的字符串遵循模式A[.[B]][e|EC]，其中A为整数，B紧跟着小数点为数值的小数部分，C紧跟‘e’或‘E’为数值指数部分。判断一个字符串是否符合上述模式，首先尽可能地多扫描0-9的数位，即整数A部分。如果遇到小数点则开始扫描表示数值小数部分的B部分。若遇到‘e’或‘E’则扫描C部分。<br>


### [038--字符串的排列](Solution038.java)
&nbsp;&nbsp;输入一个字符串，打印该字符串中字符的所有排列。<br>
&nbsp;&nbsp;分两步实现：第一步是求出所有可能出现在第一个位置的字符，即把第一个字符和后面的所有字符交换。第二步是固定第一个字符，然后求后面所有字符的排列。这时把后面的字符分为两部分：后面字符的第一个字符，以及这个字符后面的所有字符。拿第一个字符后它后面的字符逐一交换。采用递归思路实现。<br>

### [058(1)--翻转单词顺序](Solution058_1.java)
&nbsp;&nbsp;输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。<br>
&nbsp;&nbsp;借助栈实现，每次遇到空格，就将之前遍历的字符组成单词压入栈中，直至遍历结束。在从栈顶去元素，每取出一个单词中间加一个空格，直至栈空，即翻转句子中的单词顺序。思路二：先翻转句子中所有字符，再翻转每个单词中字符的顺序。<br>

### [058(2)--左旋转字符串](Solution058_2.java)
&nbsp;&nbsp;输入字符串“abcdefg”和2，返回cdefgab。<br>
&nbsp;&nbsp;将要翻转的部分当成第一部分，其余字符为第二部分。就如上例所述，首先分别翻转两部分得到“bagfedc”。然后翻转整个字符串得到“cdefgab”，即是原始字符串左旋转两位的结果。<br>


### [067--字符串转换成整数](Solution067.java)
&nbsp;&nbsp;输入一串数字，转换为整数类型<br>
&nbsp;&nbsp;先按照数字的正则表达式进行过滤，从个位开始进行数值转换，个位为10的0次方位，十位为10的一次方位..以此类推。详细见代码。<br>
