* [链表部分](#链表部分)
    * [006--从尾到头打印链表](/src/Linklist_Question/Solution006.java)
    * [018--删除链表中的重复节点](/src/Linklist_Question/Solution018.java)
    * [022--链表中倒数第k个节点](/src/Linklist_Question/Solution022.java)
    * [023--链表中环的入口](/src/Linklist_Question/Solution023.java)
    * [024--反转链表](/src/Linklist_Question/Solution024.java)
    * [025--合并两个排序的链表](/src/Linklist_Question/Solution025.java)
    * [035--复杂链表的复制](/src/Linklist_Question/Solution035.java)
    * [052--两个递增链表的第一个公共节点](/src/Linklist_Question/Solution052.java)
    
    
解题思路
------
### [006--从尾到头打印链表](Solution006.java)
&nbsp;&nbsp;书上的思路是借助栈来实现，把链表的每个节点入栈，然后再从栈顶依次输出节点的值。


&nbsp;&nbsp;我借助Java的ArrayList类实现。ArrayList是集合的一种实现，实现了List接口，底层的数据结构是数组，是非线程安全的。对ArrayList类的实例的所有操作底层都是基于数组。本题的实现思路就是通过ArrayList实例list的add(int index,Integer element)方法，将链表的每个元素添加到list的第一个位置，类似于头插法。然后顺序输出，实现从尾到头打印链表。


### [018--删除链表节点&删除链表中的重复节点](Solution018.java)
&nbsp;&nbsp;书上的思路是通过两个指针，一个是指向当前节点的pNode指针，另一个是指向当前节点前一个节点的pPreNode指针。当pNode指针与下一个节点值相同，即为重复节点，为待删节点。把当前节点的前一个节点pPreNode指针指向后面值不为待删节点的节点，实现删除重复节点功能。


&nbsp;&nbsp;我借助Java的HashSet类实现。Java中Set类继承于Collection接口，它不允许出现重复元素并且是无序的集合，主要有HashSet和TreeSet两个实现类。HashSet是哈希表结构，利用HashMap的Key来存储元素，计算插入元素的hashcode来获取元素在集合中的位置。HashSet实现Set接口，基于HashMap实现，存储唯一元素并允许空值，它不是非线程安全的。


&nbsp;&nbsp;该题的实现思路是首先遍历链表，找出相同的节点将其添加到到HashSet的set实例中。在这里使用的是add(E e)方法，HashSet的add方法调用的是底层HashMap的put()方法，首先判断元素是否存在，若不存在则插入，若存在则不插入。然后再次遍历链表，找到链表中的相同元素，将它们从列表中移除，实现此功能。



### [022--链表中倒数第k个节点](Solution022.java)
&nbsp;&nbsp;定义两个指针，第一个指针从链表的头指针开始遍历向前走k-1步，第二个指针保持不动。从第k步开始，第二个指针开始从链表的头指针开始遍历。因为两个指针之间的距离为k-1，所以当第一个指针到达链表尾节点时，第二个指针正好指向倒数第k个节点。



### [023--链表中环的入口](Solution023.java)
&nbsp;&nbsp;思路大概分为两步，首先用两个指针确定链表中是否包含环，定义两个指针同时从链表头结点出发，一个指针一次走一步，另一个指针一次走两步，若快指针追上了慢指针，则链表包含环；反之则没有环。然后是确定环的入口，将两个指针同时指向链表头结点，若该链表中的环有n个节点，则快指针fast现在链表上移动n步，然后快慢指针同时前进，当慢指针指向环的入口时，此时快指针已经绕环一圈回到入口节点，即快慢指针相遇的节点为入口节点。


&nbsp;&nbsp;如何得到环中节点的数目？快慢指针相遇后开始计数，此时两个指针均已在环中，当再次回到这个节点时，就可以统计节点数。


### [024--反转链表](Solution024.java)
&nbsp;&nbsp;总共分为4步，总结为：先存后节点，将链指向前，再将现变前，将后变为现。详细见代码。


### [025--合并两个排序的链表](Solution025.java)
&nbsp;&nbsp;比较两个有序链表的第一个节点，取小的为合并链表的第一个节点。再比较两个链表的首节点，小的加入新链表，以此类推。最后，若原来的两个链表中有剩余，则以此加入新链表的末尾。


### [035--复杂链表的复制](Solution035.java)
&nbsp;&nbsp;解题思路分3步：首先复制链表中的每一个节点，并将复制节点放在原节点的后面。其次将复制的节点同原节点random域所连节点的复制节点相连，这一步保持我的复制链表结构与原链表结构的一致性。最后是将这个长链表拆分为两个链表，设置两个指针，一个指向链表头结点，另一个指向它的下一个节点，即复制链表的第一个节点，返回复制链表的头结点。


### [052--两个递增链表的第一个公共节点](Solution052.java)
&nbsp;&nbsp;由题意，若两个单向链表有公共节点，那么这两个链表从某一节点开始，它们的next域都指向同一个节点。由于只有一个next域，因此从第一个公共节点开始，之后所有的节点都是重合的。因此解题思路为设置两个指针p1,p2分别指向两个链表头结点，同时向前移动寻找公共点。假设当p1先走到尾节点，则让p1继续从头开始遍历另一个链表的节点，p2也是如此。两个指针始终同时移动，直至指向第一个公共节点为止。







    
   
   
    
