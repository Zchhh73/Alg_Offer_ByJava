* 查找和排序
    * [011--旋转数组的最小数字](Solution011.java)
    * [050--字符串中第一个只出现一次的字符](Solution050.java)
    * [050(2)--字符流中第一个只出现一次的字符](Solution050_1.java)
    * [053--在排序数组中查找数值](Solution053.java)
    * [039--数组中出现次数超过一半的数字](Solution039.java)
    * 040--最小的k个数
    * 041--数据流中的中位数
    * 051--数组中的逆序对
    * 排序算法总结以及实现



解题思路
------
### [011--旋转数组的最小数字](Solution011.java)
&nbsp;&nbsp;此题输入一个递增数组的一个旋转，输出旋转数组的最小元素。<br>
&nbsp;&nbsp;由于是递增数组，那么即旋转之后的数组可以划分为两个排序的子数组，并且前面的子数组元素都大于或等于后面的子数组。其中最小的元素是这两个子数组的分界线。由于是排序的数组，就可以用二分查找实现O(logn)的查找。<br>


### [050--字符串中第一个只出现一次的字符](Solution050.java)
&nbsp;&nbsp;此题输入一串字符，例‘abaccdfee’，则输出‘b’。<br>
&nbsp;&nbsp;借助哈希表解决这个问题，定义哈希表的key为字符，value为该字符出现的次数。对字符进行两次遍历，第一次扫描字符串时，每扫到一个字符就在哈希表的对应项中将次数+1。第二次扫描字符串时，每扫到一个字符就能从哈希表中得到相应其对应的次数。这样就可以找到第一个只出现一次的字符。<br>

### [050(2)--字符流中第一个只出现一次的字符](Solution050_1.java)
&nbsp;&nbsp;此题输入一串字流，例当前字符流前两个字符为“go”，则输出‘g’;当字符流为"google"时,则输出'l'。<br>
&nbsp;&nbsp;字符只能一个接一个从字符流中读出来，因此可以定义一个数据容器保存字符在字符流中的位置。此题中借助列表，如果该字符第一次出现，将字符加入list；若字符在list中存在，则将字符在列表中移除。到字符流最后，列表中只会存在出现一次的字符，取列表的第一个值即字符流中第一个只出现一次的字符。<br>

### [053--在排序数组中查找数值](Solution053.java)
&nbsp;&nbsp;此题输入一个排序数组和一个数字k，统计该数字k出现的次数。<br>
&nbsp;&nbsp;由于是排序数组，因此想到二分查找。先用二分查找在数组中找到第一个k，如果中间数字比k大，则k有可能出现在数组的前半段，下一轮只需要在数组前半段查找即可；如果中间数字比k小，则k有可能出现在数组的后半段，下一轮只需要在数组后半段查找即可；如果中间的数字为k，则先判断这个数字是否为第一个k,若中间数字的前一个不是k,则该值为第一个k。若中间数字的前一个是k,则第一个k肯定在数组前半段，下一轮扔需要在数组前半段查找。<br>

### [039--数组中出现次数超过一半的数字](Solution039.java)
&nbsp;&nbsp;此题输入一个数组，返回出现次数超过一半的数字。<br>
&nbsp;&nbsp;因为数组中有一个出现次数超过一半的数字，也就是说它出现的次数比其它所有数字出现的次数之和还多。所以在遍历数组的时候保存两个值：一个是数组中的数字，另一个是次数。当遍历到下一个数字的时候，若下个数字与之前保存的数字相同，则次数+1；若不同，则次数减1。当次数减为0时，保存下一个数字并将次数设为1。要找的数字肯定是最后一次把次数设为1时对应的数字。<br>
