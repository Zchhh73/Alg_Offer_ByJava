* [算法应用](/src/Alg_Question)
    * [016--数值的整数次方](Solution016.java)
    * [017--打印从1到最大的n位数](Solution017.java)
    * [029--顺时针打印矩阵](Solution029.java)
    * [043--1\~n整数中1出现的次数](Solution043.java)
    * [044--数字序列中某一位的数字](Solution044.java)
    * [045--把数组排成最小的数](Solution045.java)
    * 049--丑数
    * 060--n个骰子的点数
    * 063--股票的最大利润
    * 064--求1+2+...+n
    * 065--不用加减乘除法做加法
    





解题思路
------
### [016--数值的整数次方](Solution016.java)
&nbsp;&nbsp;此题实现不是很难，如果底数为正数，则直接求次方值；如果底数为负数，就先取正数部分的次方值，然后取倒数。并且要做到考虑全面。比如，当输入是0，指数为负数时，相当于对0求倒数，导致程序运行错误；然后0的0次方在数学上没有意义，因此无论输出0或1都可以。<br>


### [017--打印从1到最大的n位数](Solution017.java)
&nbsp;&nbsp;输入数字n,按顺序打印1到最大n位的十进制数。<br>
&nbsp;&nbsp;解题思路是全排列递归实现，数字的每一位都可能是0到9的一个数，然后设置下一位。递归结束的条件就是我们已经设置了数字的最后一位。<br>


### [029--顺时针打印矩阵](Solution029.java)
&nbsp;&nbsp;此题输入一个矩阵，要求按顺时针打印矩阵。<br>
&nbsp;&nbsp;解题思路按两个指针输出，由4个边界指针控制，若到达上边界指针和左边界指针时，该两个指针加一；若在下边界指针和右边界指针时，该两个指针--，直到输出最后一个元素。<br>


### [043--1\~n整数中1出现的次数](Solution043.java)
&nbsp;&nbsp;输入一个整数n,求1~n这n个整数的十进制表示中1出现的次数。<br>
&nbsp;&nbsp;解题思路采用阶梯式统计，首先统计个位上的1，然后再依次统计十位、百位上的1的值。以统计十位数上1的个数，其归纳式如下：<br>
&nbsp;&nbsp;(n/100)\*10+if(k>19) 10 else if(k<10) 0 else k-10+1<br>


### [044--数字序列中某一位的数字](Solution044.java)
&nbsp;&nbsp;输入以012345678910...的格式序列化到一个字符序列中，编写一个函数，求任意第n位对应的数字。<br>
&nbsp;&nbsp;解题思路如下：以1001位为例，序列的前10位是0\~9只有1位的数字，显然1001位在这之后，因此跳过这10个数，从后面的序列中找第991（1001\-10=991）位数字。<br>
&nbsp;&nbsp;10~99共180位数字，由于991>180,因此从后面811（991-180=811）位找。100\~999共2700位，811<2700,所以第811位是某三位数的一位。因为811=270\*3+1,这意味着第811位是从100开始第270个数字，即370的中间一位，为7。<br>


### [045--把数组排成最小的数](Solution045.java)
&nbsp;&nbsp;输入一个正整数数组，把数组里面所有数字拼接排成一个数，打印能拼接出的所有数字中最小的一个<br>
&nbsp;&nbsp;解题思路是可以指定一个规则，两个数字m,n拼接为mn或nm，若mn<nm,则打印mn，即定义m<n；若nm<mn，则定义n小于m；若mn=nm，则m,n相等<br>

