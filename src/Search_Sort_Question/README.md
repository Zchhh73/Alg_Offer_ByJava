* 查找和排序
    * 011--旋转数组的最小数字
    * 050--字符串中第一个只出现一次的字符
    * 050(2)--字符流中第一个只出现一次的字符
    * 053--在排序数组中查找数值
    * 快速排序
    * 堆排序
    * 归并排序
    * 039--数组中出现次数超过一半的数字
    * 040--最小的k个数
    * 041--数据流中的中位数
    * 051--数组中的逆序对



解题思路
------
### [011--旋转数组的最小数字](Solution011.java)
&nbsp;&nbsp;此题输入一个递增数组的一个旋转，输出旋转数组的最小元素<br>
&nbsp;&nbsp;由于是递增数组，那么即旋转之后的数组可以划分为两个排序的子数组，并且前面的子数组元素都大于或等于后面的子数组。其中最小的元素是这两个子数组的分界线。由于是排序的数组，就可以用二分查找实现O(logn)的查找。<br>


### [050--字符串中第一个只出现一次的字符](Solution050.java)
&nbsp;&nbsp;此题输入一串字符，例‘abaccdfee’，则输出‘b’<br>
&nbsp;&nbsp;借助哈希表解决这个问题，定义哈希表的key为字符，value为该字符出现的次数。对字符进行两次遍历，第一次扫描字符串时，每扫到一个字符就在哈希表的对应项中将次数+1。第二次扫描字符串时，每扫到一个字符就能从哈希表中得到相应其对应的次数。这样就可以找到第一个只出现一次的字符。<br>

### [050(2)--字符流中第一个只出现一次的字符](Solution050_1.java)
&nbsp;&nbsp;此题输入一串字流，例当前字符流前两个字符为“go”，则输出‘g’;当字符流为"google"时,则输出'l'<br>
&nbsp;&nbsp; 字符只能一个接一个从字符流中读出来，因此可以定义一个数据容器保存字符在字符流中的位置。此题中借助列表，如果该字符第一次出现，将字符加入list；若字符在list中存在，则将字符在列表中移除。到字符流最后，列表中只会存在出现一次的字符，取列表的第一个值即字符流中第一个只出现一次的字符<br>
