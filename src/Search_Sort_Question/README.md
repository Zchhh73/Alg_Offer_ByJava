* 查找和排序
    * [7个排序方法的实现](SortOption.java)
    * [011--旋转数组的最小数字](Solution011.java)
    * [050--字符串中第一个只出现一次的字符](Solution050.java)
    * [050(2)--字符流中第一个只出现一次的字符](Solution050_1.java)
    * [053--在排序数组中查找数值](Solution053.java)
    * [039--数组中出现次数超过一半的数字](Solution039.java)
    * [040--最小的k个数](Solution040.java)
    * [041--数据流中的中位数](Solution041.java)
    * [051--数组中的逆序对](Solution051.java)
   



解题思路
------
### [011--旋转数组的最小数字](Solution011.java)
&nbsp;&nbsp;此题输入一个递增数组的一个旋转，输出旋转数组的最小元素。<br>
&nbsp;&nbsp;由于是递增数组，那么即旋转之后的数组可以划分为两个排序的子数组，并且前面的子数组元素都大于或等于后面的子数组。其中最小的元素是这两个子数组的分界线。由于是排序的数组，就可以用二分查找实现O(logn)的查找。<br>


### [050--字符串中第一个只出现一次的字符](Solution050.java)
&nbsp;&nbsp;此题输入一串字符，例‘abaccdfee’，则输出‘b’。<br>
&nbsp;&nbsp;借助哈希表解决这个问题，定义哈希表的key为字符，value为该字符出现的次数。对字符进行两次遍历，第一次扫描字符串时，每扫到一个字符就在哈希表的对应项中将次数+1。第二次扫描字符串时，每扫到一个字符就能从哈希表中得到相应其对应的次数。这样就可以找到第一个只出现一次的字符。<br>

### [050(2)--字符流中第一个只出现一次的字符](Solution050_1.java)
&nbsp;&nbsp;此题输入一串字流，例当前字符流前两个字符为“go”，则输出‘g’;当字符流为"google"时,则输出'l'。<br>
&nbsp;&nbsp;字符只能一个接一个从字符流中读出来，因此可以定义一个数据容器保存字符在字符流中的位置。此题中借助列表，如果该字符第一次出现，将字符加入list；若字符在list中存在，则将字符在列表中移除。到字符流最后，列表中只会存在出现一次的字符，取列表的第一个值即字符流中第一个只出现一次的字符。<br>

### [053--在排序数组中查找数值](Solution053.java)
&nbsp;&nbsp;此题输入一个排序数组和一个数字k，统计该数字k出现的次数。<br>
&nbsp;&nbsp;由于是排序数组，因此想到二分查找。先用二分查找在数组中找到第一个k，如果中间数字比k大，则k有可能出现在数组的前半段，下一轮只需要在数组前半段查找即可；如果中间数字比k小，则k有可能出现在数组的后半段，下一轮只需要在数组后半段查找即可；如果中间的数字为k，则先判断这个数字是否为第一个k,若中间数字的前一个不是k,则该值为第一个k。若中间数字的前一个是k,则第一个k肯定在数组前半段，下一轮扔需要在数组前半段查找。<br>

### [039--数组中出现次数超过一半的数字](Solution039.java)
&nbsp;&nbsp;此题输入一个数组，返回出现次数超过一半的数字。<br>
&nbsp;&nbsp;因为数组中有一个出现次数超过一半的数字，也就是说它出现的次数比其它所有数字出现的次数之和还多。所以在遍历数组的时候保存两个值：一个是数组中的数字，另一个是次数。当遍历到下一个数字的时候，若下个数字与之前保存的数字相同，则次数+1；若不同，则次数减1。当次数减为0时，保存下一个数字并将次数设为1。要找的数字肯定是最后一次把次数设为1时对应的数字。<br>

### [040--最小的k个数](Solution040.java)
&nbsp;&nbsp;此题输入一个数组和一个数字k，统计该数组中最小的k个值。<br>
&nbsp;&nbsp;此题采用最大堆来实现，在最大堆中，根节点的值总是大于它的子树中任意节点的值。因此当我们找到最大值时，便将其与数组末尾的值交换。然后保持最大堆的性质，比较的数组长度-1。依次类推，最终得到一个升序排序的数组，取前k个即为最小的k个数。堆排序时间复杂度为O(nlogn),而且适合处理海量数据。<br>

### [041--数据流中的中位数](Solution041.java)
&nbsp;&nbsp;此题采用插入排序实现。从数据流中读出数据可以借助一个列表按顺序保存，即在数组里插入新数据时按顺序插入，因为需要移动n个数，因此需要O(n)时间才能完成插入操作。在已排序好的数组中找到中位数，只需要O(1)时间即可完成。<br>

### [051--数组中的逆序对](Solution051.java)
&nbsp;&nbsp;此题借助归并排序的思路实现。统计逆序对的过程为：先把数组分成子数组，统计出子数组内部的逆序对的数目，然后再统计出两个相邻子数组之间的逆序对的数目。在统计逆序对的过程中，还需要对数组进行排序。<br>

### [7个排序方法的实现](SortOption.java)
&nbsp;&nbsp;总结冒泡排序、选择排序、插入排序、希尔排序、快速排序、归并排序，堆排序共7中排序方法的实现。<br>
