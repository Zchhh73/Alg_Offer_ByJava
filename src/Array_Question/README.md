* 数组类型
    * [003(1)--数组中重复的数字](Solution003.java)
    * [003(2)--数组中重复的数字(不修改数组)](Solution003.java)
    * [004--二维数组的查找](Solution004.java)
    * [021--调整数组顺序使奇数位于偶数前面](Solution021.java)
    * [056--数组中数字出现的次数](Solution056.java)
    * [057--和为s的数字](Solution057.java)
    * [061--扑克牌中的顺子](Solution061.java)
    * [066--构建乘积数组](Solution066.java)

   



解题思路
------
### [003(1)--数组中重复的数字](Solution003.java)
&nbsp;&nbsp;此题在长度为n的数组里所有数字为0\~n-1的范围内，找出数组中重复的数字<br>
&nbsp;&nbsp;解题思路由于数组中的数字都在0\~n-1范围内，若数组中没有重复的数字，那么数组排序后数字i将出现在下标为i的位置。因此若存在重复数字，则重排该数组，依次扫描数组中的每个数字，当扫描到下标为i的数字时，首先比较这个数字是不是等于i，若是，则遍历下一个数字；若不是，则与第i个位置的数字交换。依次类推，当交换的时候若i下标位置的已经为数值i，则判断出现了重复数字，将它保存到存储重复数字的数组中。此题为改变了数组来查找重复数字。<br>

### [003(2)--不修改数组找出重复的数字](Solution003.java)
&nbsp;&nbsp;此题在长度为n+1的数组里所有数字为1\~n的范围内，所以数组中至少一个数字重复。找出数组中重复的数字，条件是不能修改输入的数组。<br>
&nbsp;&nbsp;解题思路采用二分查找的方法解决。把1\~n的数字从中间数字m分成两部分。若前一半1\~m的数字数目超过m个，说明重复数字在前一半区间，否则，在后半区间m+1\~n。每次在区间中都一分为二，直到找到重复数字。<br>

### [004--二维数组的查找](Solution004.java)
&nbsp;&nbsp;实现一个函数，输入一个二维数组和一个整数，该二维数组每一行从左到右递增，每一列从上到下递增，判断数组中是否含有该整数。<br>
&nbsp;&nbsp;解题思路是选取数组中右上角的值，如果该数字等于要查找的数字，则查找过程结束；如果该数字大于要查找的数字，则向前搜索一列，因为该数为这一列的最小值；如果该数字小于要查找的数字，则向下一行进行查找，因为这个数为该行的最大值。依次类推，一步一步剔除每一行每一列，缩小查找范围，直至找到要查找的数字，或者为空终止。<br>

### [021--调整数组顺序使奇数位于偶数前面](Solution021.java)
&nbsp;&nbsp;输入一个数组，实现一个函数，使所有奇数位于数组前半部分，偶数位于数组后半部分。<br>
&nbsp;&nbsp;解题思路是使用两个指针，第一个指针初始化指向数组第一个位置且向后移动，第二个指针指向最后一个位置且向前移动。如果第一个指针指向偶数，且第二个指针指向奇数时，交换两个数字，不过这种方法改变了奇偶数的相对顺序。时间复杂度O(n)<br>
&nbsp;&nbsp;第二种思路是不改变奇数偶数的相对顺序，同样利用两个指针，位置为一前一后。初始化时设置第一个指针指向数组开始，遍历整个数组，当遍历的数是奇数时，指针向后移动；当指针指向偶数时停下，启动第二个指针，第二个指针位置从第一个指针的后一位开始遍历，直到找到下一个奇数的位置才停止。此时right为奇数，left为偶数，交换它们。left和right中间的数值都向后移1位，将right的奇数值覆盖left。时间复杂度O(n^2)<br>
