* 数组类型
    * [003(1)--数组中重复的数字](Solution003.java)
    * [003(2)--数组中重复的数字(不修改数组)](Solution003.java)
    * [004--二维数组的查找](Solution004.java)
    * [021--调整数组顺序使奇数位于偶数前面](Solution021.java)
    * [053(1)--数字在排序数组中出现的次数](Solution053_1.java)
    * [053(2)--0\~n-1中缺失的数字](Solution053_2.java)
    * [053(3)--数组中数值和下标相等的元素](Solution053_3.java)
    * [056--数组中数字出现的次数](Solution056.java)
    * [056(2)--数组中唯一出现一次的数字](Solution056_2.java)
    * [057--和为s的数字](Solution057.java)
    * [057(2)--和为s的连续正数序列](Solution057_2.java)
    * [061--扑克牌中的顺子](Solution061.java)
    * [066--构建乘积数组](Solution066.java)

   



解题思路
------
### [003(1)--数组中重复的数字](Solution003.java)
&nbsp;&nbsp;此题在长度为n的数组里所有数字为0\~n-1的范围内，找出数组中重复的数字<br>
&nbsp;&nbsp;解题思路由于数组中的数字都在0\~n-1范围内，若数组中没有重复的数字，那么数组排序后数字i将出现在下标为i的位置。因此若存在重复数字，则重排该数组，依次扫描数组中的每个数字，当扫描到下标为i的数字时，首先比较这个数字是不是等于i，若是，则遍历下一个数字；若不是，则与第i个位置的数字交换。依次类推，当交换的时候若i下标位置的已经为数值i，则判断出现了重复数字，将它保存到存储重复数字的数组中。此题为改变了数组来查找重复数字。<br>

### [003(2)--不修改数组找出重复的数字](Solution003.java)
&nbsp;&nbsp;此题在长度为n+1的数组里所有数字为1\~n的范围内，所以数组中至少一个数字重复。找出数组中重复的数字，条件是不能修改输入的数组。<br>
&nbsp;&nbsp;解题思路采用二分查找的方法解决。把1\~n的数字从中间数字m分成两部分。若前一半1\~m的数字数目超过m个，说明重复数字在前一半区间，否则，在后半区间m+1\~n。每次在区间中都一分为二，直到找到重复数字。<br>

### [004--二维数组的查找](Solution004.java)
&nbsp;&nbsp;实现一个函数，输入一个二维数组和一个整数，该二维数组每一行从左到右递增，每一列从上到下递增，判断数组中是否含有该整数。<br>
&nbsp;&nbsp;解题思路是选取数组中右上角的值，如果该数字等于要查找的数字，则查找过程结束；如果该数字大于要查找的数字，则向前搜索一列，因为该数为这一列的最小值；如果该数字小于要查找的数字，则向下一行进行查找，因为这个数为该行的最大值。依次类推，一步一步剔除每一行每一列，缩小查找范围，直至找到要查找的数字，或者为空终止。<br>

### [021--调整数组顺序使奇数位于偶数前面](Solution021.java)
&nbsp;&nbsp;输入一个数组，实现一个函数，使所有奇数位于数组前半部分，偶数位于数组后半部分。<br>
&nbsp;&nbsp;解题思路是使用两个指针，第一个指针初始化指向数组第一个位置且向后移动，第二个指针指向最后一个位置且向前移动。如果第一个指针指向偶数，且第二个指针指向奇数时，交换两个数字，不过这种方法改变了奇偶数的相对顺序。时间复杂度O(n)<br>
&nbsp;&nbsp;第二种思路是不改变奇数偶数的相对顺序，同样利用两个指针，位置为一前一后。初始化时设置第一个指针指向数组开始，遍历整个数组，当遍历的数是奇数时，指针向后移动；当指针指向偶数时停下，启动第二个指针，第二个指针位置从第一个指针的后一位开始遍历，直到找到下一个奇数的位置才停止。此时right为奇数，left为偶数，交换它们。left和right中间的数值都向后移1位，将right的奇数值覆盖left。时间复杂度O(n^2)<br>


### [053(1)--数字在排序数组中出现的次数](Solution053_1.java)
&nbsp;&nbsp;此题统计一个数字在排序数组中出现的次数。例如输入{1,2,3,3,3,3,4,5}和数字k=3，输出3出现的次数4。<br>
&nbsp;&nbsp;解题思路是既然是排序数组，那么就使用二分查找法解决，先用二分查找法找到中间的数是不是k，如果中间数字比k大，k只能出现在数组前半部分；如果中间数字比k小，k只能出现在数组后半部分；若等于k,则判读这个数字是不是第一个k，若中间数的前一位不是k,则此时中间数刚好为第一个k；若中间数的前一位是k，则第一个k肯定在数组的前半部，下一轮仍要去数组的前半部查找。依次类推统计k的数量。<br>

### [053(2)--0\~n-1中缺失的数字](Solution053_2.java)
&nbsp;&nbsp;输入一个长度为n-1的递增数组，数值范围都在0\~n-1内且唯一，在0\~n-1内的数字中有且只有一个数字不在该数组中，请找出这个数字<br>
&nbsp;&nbsp;解题思路是基于二分查找的方法，如果中间元素的值和下标相等，则下一轮只需要查找右半部分；若中间元素和下标不相等，且它前面的元素值和它的下标相等，说明这个中间的数字正好是第一个值和下标不相等的元素，它的下标就是数组中不存在的数字；若中间元素和下标不相等，且它前面的元素值和它的下标不相等，说明下一轮在数组左半边查找即可。<br>

### [053(3)--数组中数值和下标相等的元素](Solution053_3.java)
&nbsp;&nbsp;输入一个单调递增的数组，且数组中元素唯一。编写函数找出数组中任意一个数值等于下标的元素。<br>
&nbsp;&nbsp;解题思路是由于数组单调递增，使用二分查找来进行优化，如果某一步抵达数组中第i个数字，该位置的数值也是i，则找到了一个数字和其下标相等的元素。如果我们找到的这个元素的数值大于它的下标，那么这个位置右边的数字都大于它的下标，可以忽略，下一轮只在左边的数字查找即可；如果我们找到的这个元素的数值小于它的下标，那么这个位置左边的数字都小于它的下标，忽略后从右边的数字查找即可。依次类推直到找到对应下标的元素。<br>

### [056(1)--数组中数字出现的次数](Solution056.java)
&nbsp;&nbsp;输入一个数组，该数组除两个数字外，其他数字都出现两次。请找出这两个只出现一次的数字。<br>
&nbsp;&nbsp;解题思路是考虑异或运算的一个性质：任何一个数字异或它自己都等于0。如果依次异或数组中的每个数字，那么最终结果刚好是只出现一次的数字，因为成对出现两次的数字全部在异或中抵消了。然后在结果中找到第一个为1的位的位置，记为第n位。现在以第n位是不是为1来划分子数组，第一个子数组每个数字的第n位都是1，第二个子数组每个数字的第n位都是0。按此标准分类的子数组，已经将出现了两次的数字分配到同一个子数组中，这样每个子数组中都存在一个只出现一次的数字，再对子数组分别进行异或操作，能获得这两个数字。<br>

### [056(2)--数组中唯一出现一次的数字](Solution056.java)
&nbsp;&nbsp;输入一个数组，该数组除一个数字只出现一次以外，其他数字都出现了3次，请找出那个只出现1次的数字。<br>
&nbsp;&nbsp;解题思路还是用异或思想简化问题。如果一个数字出现三次，那么它的二进制表示的每一位也出现三次，如果把所有出现三次的数字的二进制表示的每一位都分别加起来，那么每一位的和都能被3整除。把数组中所有数字的二进制表示的每一位都加起来，如果某一位的和能被3整除，那么那个只出现一次的数字二进制表示中对应的那一位的是0，否则就是1。<br>

### [057--和为s的数字](Solution057.java)
&nbsp;&nbsp;输入一个递增排序的数组和一个数字是，在数组中查找两个数，使他们的和正好是s，输出所有组合。<br>
&nbsp;&nbsp;解题思路是使用两个指针，第一个指向开头，第二个指向末尾，求这两个数的和。若结果大于s，则末尾指针前移；若和小于s，则前面的指针后移。若等于s，保留该结果到list，以此类推继续遍历寻找，直至跳出循环条件。<br>

### [057--和为s的连续正数序列](Solution057_2.java)
&nbsp;&nbsp;输入一个正数s，打印出所有和为s的连续正数序列。输出所有可能的组合。<br>
&nbsp;&nbsp;解题思路是同样使用两个连续指针，将left初始化1，right初始化2。序列的和为3，若小于s，则要加入更多的数，因此right++；当序列的值大于s时，则说明序列中的数多出来了，此时让left++，直至找到和为s的正数序列，将他们生成为一个list输出。<br>

### [061--扑克牌中的顺子](Solution061.java)
&nbsp;&nbsp;从扑克牌中随机抽5张牌，判断是不是一个顺子，A为1，J为11，Q为12，K为13，大小王即0为任意数字。<br>
&nbsp;&nbsp;解题思路为：首先将数组排序；其次统计数组中0的个数；最后统计排序之后数组中相邻数字的空缺总数，若空缺总数小于或等于0的个数，则该数组连续，反之则不联系。如果数组中的非0数字重复出现，则该数组不是连续的。<br>

### [066--构建乘积数组](Solution066.java)
&nbsp;&nbsp;给定一个数组A\[\],请构建一个数组B\[\]，其中B中元素B\[i\]=A\[0\]\*A\[1\]...\*A\[i-1\]\*A\[i+1\]...\*A\[n-1\],不能使用除法。<br>
&nbsp;&nbsp;解题思路是将乘积数组分为两个三角矩阵，上三角自上而下进行计算，下三角自下而上进行计算。最后将每一行的左右部分相乘即构建完毕。详细见代码。<br>





