* [算法应用](/src/Alg_Question)
    * [016--数值的整数次方](Solution016.java)
    * [017--打印从1到最大的n位数](Solution017.java)
    * [029--顺时针打印矩阵](Solution029.java)
    * [043--1\~n整数中1出现的次数](Solution043.java)
    * [044--数字序列中某一位的数字](Solution044.java)
    * [045--把数组排成最小的数](Solution045.java)
    * [049--丑数](Solution049.java)
    * [063--股票的最大利润](Solution063.java)
    * [064--求1+2+...+n](Solution064.java)    





解题思路
------
### [016--数值的整数次方](Solution016.java)
&nbsp;&nbsp;此题实现不是很难，如果底数为正数，则直接求次方值；如果底数为负数，就先取正数部分的次方值，然后取倒数。并且要做到考虑全面。比如，当输入是0，指数为负数时，相当于对0求倒数，导致程序运行错误；然后0的0次方在数学上没有意义，因此无论输出0或1都可以。<br>


### [017--打印从1到最大的n位数](Solution017.java)
&nbsp;&nbsp;输入数字n,按顺序打印1到最大n位的十进制数。<br>
&nbsp;&nbsp;解题思路是全排列递归实现，数字的每一位都可能是0到9的一个数，然后设置下一位。递归结束的条件就是我们已经设置了数字的最后一位。<br>


### [029--顺时针打印矩阵](Solution029.java)
&nbsp;&nbsp;此题输入一个矩阵，要求按顺时针打印矩阵。<br>
&nbsp;&nbsp;解题思路按两个指针输出，由4个边界指针控制，若到达上边界指针和左边界指针时，该两个指针加一；若在下边界指针和右边界指针时，该两个指针--，直到输出最后一个元素。<br>


### [043--1\~n整数中1出现的次数](Solution043.java)
&nbsp;&nbsp;输入一个整数n,求1~n这n个整数的十进制表示中1出现的次数。<br>
&nbsp;&nbsp;解题思路采用阶梯式统计，首先统计个位上的1，然后再依次统计十位、百位上的1的值。以统计十位数上1的个数，其归纳式如下：<br>
&nbsp;&nbsp;(n/100)\*10+if(k>19) 10 else if(k<10) 0 else k-10+1<br>


### [044--数字序列中某一位的数字](Solution044.java)
&nbsp;&nbsp;输入以012345678910...的格式序列化到一个字符序列中，编写一个函数，求任意第n位对应的数字。<br>
&nbsp;&nbsp;解题思路如下：以1001位为例，序列的前10位是0\~9只有1位的数字，显然1001位在这之后，因此跳过这10个数，从后面的序列中找第991（1001\-10=991）位数字。<br>
&nbsp;&nbsp;10~99共180位数字，由于991>180,因此从后面811（991-180=811）位找。100\~999共2700位，811<2700,所以第811位是某三位数的一位。因为811=270\*3+1,这意味着第811位是从100开始第270个数字，即370的中间一位，为7。<br>


### [045--把数组排成最小的数](Solution045.java)
&nbsp;&nbsp;输入一个正整数数组，把数组里面所有数字拼接排成一个数，打印能拼接出的所有数字中最小的一个<br>
&nbsp;&nbsp;解题思路是可以指定一个规则，两个数字m,n拼接为mn或nm，若mn<nm,则打印mn，即定义m<n；若nm<mn，则定义n小于m；若mn=nm，则m,n相等<br>


### [049--丑数](Solution049.java)
&nbsp;&nbsp;将只包含因子2,3,5的数称为丑数，求从小到大排序的第1500个丑数<br>
&nbsp;&nbsp;解题思路是可以根据丑数的定义，丑数是另一个丑数乘以2、3或5的结果。因此可以创建一个数组，里面的数字是排好序的丑数，每个丑数都是前面的丑数乘以2、3或5得到的，并且希望丑数是按照从小到大的顺序生成的。<br>




### [063--股票的最大利润](Solution063.java)
&nbsp;&nbsp;假设把股票的价格按照时间先后顺序存储在数组中，问买卖该股票一次可能获得的最大利润是多少？<br>
&nbsp;&nbsp;解题思路是先定义函数diff(i)为当卖出价为数组第i个数字时可能获得的最大利润。显然在卖出价固定时，买入价越低获得的利润越大。即如果在扫描到数组中的第i个数字时，只要能记住之前i-1个数字中的最小值，就能算出当前价位卖出的最大利润。时间复杂度O(n)。<br>



### [064--求1+2+...+n](Solution064.java)
&nbsp;&nbsp;不使用乘除法，for...计算1+2+..+n<br>
&nbsp;&nbsp;得到通式计算即可，除以2可用右移1位代替。<br>




